// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async generateMnemonic(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('generate_mnemonic') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async createWallet(
    mnemonic: string,
    passphrase: string,
    name: string
  ): Promise<Result<boolean, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_wallet', {
          mnemonic,
          passphrase,
          name
        })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async chainStatus(): Promise<Result<SyncStatus, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('chain_status') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getAvailableWallets(): Promise<Result<AvailableWallet[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_available_wallets') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async unlockWallet(
    walletId: number,
    passphrase: string
  ): Promise<Result<UnlockMsg, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('unlock_wallet', { walletId, passphrase })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async forgetWallet(walletId: number): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('forget_wallet', { walletId })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async startNode(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('start_node') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async ethChainInfo(): Promise<Result<ChainInfo, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('eth_chain_info') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async ethGetBalance(address: string): Promise<Result<Balance, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('eth_get_balance', { address })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async ethPrepareSendTx(
    req: PrepareSendTxReq
  ): Promise<Result<PrepareTxReqRes, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('eth_prepare_send_tx', { req })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async ethSignAndSendTx(walletId: number): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('eth_sign_and_send_tx', { walletId })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async ethVerifyAddress(address: string): Promise<Result<boolean, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('eth_verify_address', { address })
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  }
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type AvailableWallet = { id: number; name: string | null }
export type Balance = { wei: string; tokens: TokenBalance[] }
export type BitcoinUnlock = { address: string; change_address: string }
export type ChainInfo = {
  block_number: string
  block_hash: string
  base_fee_per_gas: string | null
}
export type EthereumUnlock = { address: string }
export type PrepareSendTxReq = {
  token_symbol: string
  amount: string
  recipient: string
  sender: string
}
export type PrepareTxReqRes = { gas_limit: string; gas_price: string }
export type SyncStatus = { height: number; sync_completed: boolean }
export type TokenBalance = {
  symbol: string
  balance: string
  decimals: number
  ui_precision: number
}
export type UnlockMsg = { ethereum: EthereumUnlock; bitcoin: BitcoinUnlock }

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg)
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          }
        })
      }
    }
  )
}
